/****************************************************
 * @file    04_1_associative_set_multiset.cc
 * @brief   set or multiset
 *          关联容器采用二叉树实现
 *          关联容器的关键属性是它始终保持排序状态
 *          当你向二叉树插入一个元素时,该元素会被放置到
 *          正确的位置.
 *          当你从树中移除一个元素时,树会被重新调整以保持
 *          所有元素的有序性.关联容器中的元素根据特定
 *          标准进行排序,默认情况下,该标准是 < 运算符
 *          由于容器是始终排序的,那么某些操作是没有意义的
 *          例如push_back()和push_front()
 *
 *          multiset是允许元素重复的,即可插入集合原有的
 *          元素值.且set/multiset的元素都是只读的
 *          *iterator是一个不可修改的量,原因是会破坏原有
 *          的数据结构,元素就可能不再被排序了
 *
 *
 *          查找很快 O(log(n))
 *          遍历速度很慢 也面临与list相同的问题
 *          即局部性很差.因此与vector和deque相比也很慢
 *          没有随机访问 没有[]运算符
 * @author  bitofux
 * @date    2025-08-18
 ****************************************************/
#include "03_containers.hpp"

/*
 * set不允许有重复元素
 * */
int main() {
    std::set<int> myset;

    // 插入元素 -> O(log(n))
    myset.insert(1);
    myset.insert(3);
    myset.insert(7);  // 每次插入都需要进行一次排序

    // 对数时间的搜索是关联容器最重要的特性
    std::set<int>::iterator it;
    it = myset.find(7);  // O(log(n)) 指向7
    // 序列容器需要线性时间进行搜索 无find成员函数
    // 因为查找操作耗时过长

    // 插入会返回一对值,std::pair会接受一对值
    // 第一个值是一个迭代器,指向插入成功的元素或插入
    // 失败的重复元素
    // 第二个值是一个bool值,表示是否插入成功
    std::pair<std::set<int>::iterator, bool> ret;
    ret = myset.insert(3);  // set不允许有重复的元素,
                            // 不会插入3,此时返回的是
                            // 指向重复元素3的迭代器
    if (false == ret.second) {
        it = ret.first;  // it now points to element 3
    }

    // 看下面的插入操作:
    // 此时it指向3,你以为会在3的前面插入一个9是吗
    // 但其实不是,插入的位置不是it决定的,是由插入的值自身
    // 决定的,因为它始终是有序的,每次插入都需要一次排序.
    // 那么,如果该位置不用于插入,为什么插入函数还需要
    // 迭代器参数呢?实际上迭代器主要是用来提示或者帮助
    // 找到9应该要插入的位置.如果你能提供好的提示,就可以
    // 将插入时间从对数时间减少到常数时间.所以9会被插入
    // 到集合的末尾,并且it这个迭代器仍然是指向3的.
    myset.insert(it, 9);  // myset: {1,3,7,9}

    // 通过迭代器删除指向的元素
    myset.erase(it);  // myset : {1,7,9}

    // 还可以通过值删除元素
    myset.erase(7);  // myset : {1,9}
    // 这种删除操作也受益于关联容器的对数时间搜索
    // 序列容器不支持这种值删除,因为还需要进行查找
    // 序列容器太慢了!!
    for (auto& ref : myset) {
        std::cout << ref << " ";
    }
    std::cout << "\n";

    return 0;
}
